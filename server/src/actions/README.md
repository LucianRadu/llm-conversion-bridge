# Adding New MCP Actions

This guide explains how to add new MCP actions to the project.

## Action Structure

All MCP actions follow a consistent structure and are automatically discovered by the build system.

### Basic Action Template

Create a new file `server/src/actions/myAction.ts`:

```typescript
import { z } from "zod";
import type { Action, ActionHandlerResult } from "../types";

const myAction: Action = {
  version: '0.0.1',
  name: "myAction",
  isPublished: true,
  hasAemWidget: false,
  definition: {
    title: "My Action",
    description: "Description of what this action does",
    inputSchema: z.object({
      query: z.string().describe("Input parameter description"),
      limit: z.number().optional().describe("Optional parameter"),
    }),
  },
  handler: async (args: { query: string; limit?: number }): Promise<ActionHandlerResult> => {
    try {
      // Action implementation logic here
      const result = `Processed: ${args.query}`;

      return {
        content: [{
          type: "text" as const,
          text: result
        }],
        success: true,
        timestamp: Date.now()
      };
    } catch (error: any) {
      return {
        content: [{
          type: "text" as const,
          text: `Error: ${error.message}`
        }],
        success: false,
        error: error.message,
        timestamp: Date.now()
      };
    }
  }
};

export default myAction;
```

### Widget-Enabled Action Template

For actions that need to display widgets (interactive UI components):

```typescript
import { z } from "zod";
import type { Action, ActionHandlerResult } from "../types";

const myWidgetTool: Action = {
  version: '0.0.1',
  name: "myWidgetTool",
  isPublished: true,
  hasAemWidget: true,  // Enable AEM Widget support
  definition: {
    title: "My Widget Tool",
    description: "Tool that displays results in a widget",
    inputSchema: z.object({
      // Define your input parameters
    }),
  },
  handler: async (args: {}): Promise<ActionHandlerResult> => {
    try {
      const data = {
        // Data that will be passed to the widget via window.openai.toolOutput
        timestamp: new Date().toISOString(),
        message: "Widget data"
      };

      return {
        content: [{
          type: "text" as const,
          text: "Widget tool executed successfully"
        }],
        structuredContent: data,  // This data is available to the widget
        _meta: {
          "openai/outputTemplate": "ui://aem-widget/my-widget-tool.html",
          "openai/toolInvocation/invoking": "Loading widget...",
          "openai/toolInvocation/invoked": "Widget ready",
          "openai/widgetAccessible": true,
          "openai/resultCanProduceWidget": true,
        },
        success: true,
        timestamp: Date.now()
      };
    } catch (error: any) {
      return {
        content: [{
          type: "text" as const,
          text: `Error: ${error.message}`
        }],
        success: false,
        error: error.message,
        timestamp: Date.now()
      };
    }
  }
};

export default myWidgetTool;
```

## Tool Properties

### Required Properties

- **`name`**: Unique identifier for the action (used in API calls)
- **`version`**: Tool version (required)
- **`isPublished`**: Set to `true` to include the action in the MCP server
- **`hasAemWidget`**: Set to `true` to enable AEM Widget support, or `false` if no widget
- **`definition.title`**: Human-readable tool name
- **`definition.description`**: Clear description of what the action does
- **`definition.inputSchema`**: Zod schema defining input parameters
- **`handler`**: Async function that implements the action logic

### Input Schema Guidelines

Use Zod to define strongly-typed input parameters:

```typescript
inputSchema: z.object({
  // Required string parameter
  query: z.string().describe("Search query"),

  // Optional number with default
  limit: z.number().default(10).describe("Maximum results"),

  // Optional string parameter
  category: z.string().optional().describe("Filter by category"),

  // Boolean parameter
  includeMetadata: z.boolean().default(false).describe("Include metadata in results"),

  // Enum parameter
  sortBy: z.enum(["date", "relevance", "title"]).default("relevance").describe("Sort order"),
}),
```

## File Generation

The action index is automatically generated by the build system:

### Manual Generation
```bash
# Generate actions index only
make generate-actions

# Generate both actions and AEM Widgets
make generate-all
```

### Automatic Generation
The action index is automatically generated during:
- `make build`
- `make build-ts`
- `make dev`
- `npm run build:fastly`
- `npm run dev`

## Tool Registration

Tools are automatically registered with the MCP server when:

1. **File exists**: `server/src/actions/myAction.ts`
2. **Published**: `isPublished: true` in the action definition
3. **Index generated**: `make generate-actions` has been run

## AEM Widget Support

If your action has `hasAemWidget: true`, you also need to create a corresponding AEM Widget:

1. **Create the action** with `hasAemWidget: true`
2. **Create the widget HTML file**: `server/src/widgets/myWidget/myWidget.html`
3. **Create the widget metadata file**: `server/src/widgets/myWidget/myWidget.ts`
4. **Run generation**: `make generate-all`

The build system automatically embeds the HTML content and links it to your action.

See [Adding New AEM Widgets](../widgets/README.md) for detailed AEM Widget creation instructions.

## Best Practices

### 1. Tool Naming
- Use camelCase for tool names
- Make names descriptive but concise
- Avoid generic names like "search" or "get"

### 2. Error Handling
- Always wrap handler logic in try/catch
- Return consistent error format
- Include meaningful error messages

### 3. Input Validation
- Use Zod schemas for type safety
- Add descriptions to all parameters
- Set appropriate defaults for optional parameters

### 4. Response Format
- Always return `ActionHandlerResult`
- Include `success` and `timestamp` fields
- Use `content` array for text responses
- Use `structuredContent` for widget data

### 5. Performance
- Keep handlers lightweight and fast
- Use appropriate timeouts for external calls
- Consider caching for expensive operations

## Examples

See existing actions for reference:
- **`heartbeat.ts`**: Simple tool with no parameters
- **`heartbeatWidget.ts`**: Widget-enabled tool example
- **`contentSearch.ts`**: Complex tool with external API integration

## Testing

Actions are automatically tested through the integration test suite. Add specific tests for complex actions in `tests/actions/`.

## Debugging

Use the MCP Inspector to test tools locally:
1. Start the server: `make serve`
2. Open inspector: `npx @modelcontextprotocol/inspector`
3. Connect to: `http://127.0.0.1:7676/mcp-boilerplate`
4. Test your action interactively

**Note**: The MCP endpoint path is defined by `MCP_TRANSPORT_PATH` in `../constants/mcp.ts`.